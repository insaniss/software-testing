<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Тестирование ПО</title>
</head>
<body>
<div>
  <header>
    <h1>Список экзаменационных вопросов</h1>
    <ul>
      <li><a href="#q1">1. Понятие тестирования ПО. Основные определения.</a></li>
      <li><a href="#q2">2. Цели и принципы тестирования (ISTQB).</a></li>
      <li><a href="#q3">3. Основная цель тестирования. Уровень доверия, корректное поведение, реальное окружение.</a></li>
      <li><a href="#q4">4. Тестирование и качество. Уровни восприятия тестирования в компании.</a></li>
      <li><a href="#q5">5. Участники тестирования, их роль, квалификация и обязанности.</a></li>
      <li><a href="#q6">6. Мониторинг прогресса и контроль тестирования (ISTQB)</a></li>
      <li><a href="#q7">7. Модульное тестирование. Понятие модуля. Драйверы и заглушки.</a></li>
      <li><a href="#q8">8. V-образная модель. Статическое и динамическое тестирование.</a></li>
      <li><a href="#q9">9. Валидация и верификация. Тестирование методом "чёрного" и "белого" ящика.</a></li>
      <li><a href="#q10">10. Тестовый случай, тестовый сценарий и тестовое покрытие.</a></li>
      <li><a href="#q11">11. Полное тестовое покрытие. Оценка объема и времени полного покрытия.</a></li>
      <li><a href="#q12">12. Повторяемость тестового сценария. Автоматизированное тестирование. Регрессионное тестирование.</a></li>
      <li><a href="#q13">13. Цели и задачи интеграционного тестирования. Алгоритм интеграционного тестирования. Стратегии интеграции.</a></li>
      <li><a href="#q14">14. Тестирование системы целиком - системное тестирование.</a></li>
      <li><a href="#q15">15. Тестирование возможностей, стабильности, отказоустойчивости, совместимости. Тестирование производительности - CARAT.</a></li>
      <li><a href="#q16">16. Альфа и Бета тестирование. Приемочное тестирование.</a></li>
      <li><a href="#q17">17. Статическое тестирование. Рецензия, технические анализ, сквозной контроль.</a></li>
      <li><a href="#q18">18. Статическое тестирование. Инспекции.</a></li>
      <li><a href="#q19">19. Статическое тестирование. Статический анализ кода.</a></li>
      <li><a href="#q20">20. Выбор тестового покрытия с помощью анализа эквивалентности. Анализ граничных значений.</a></li>
      <li><a href="#q21">21. Выбор тестового покрытия с помощью таблицы решений.</a></li>
      <li><a href="#q22">22. Выбор тестового покрытия с помощью диаграммы состояний и таблицы переходов.</a></li>
      <li><a href="#q23">23. Выбор тестового покрытия с помощью функционального тестирования.</a></li>
      <li><a href="#q24">24. Библиотека JUnit. Класс junit.framework.Assert. Основные аннотации для исполнения тестов.</a></li>
      <li><a href="#q25">25. Библиотека JUnit. Дополнительные возможности, запуск с параметрами.</a></li>
      <li><a href="#q26">26. Анализ эквивалентности с использованием JUnit.</a></li>
      <li><a href="#q27">27. Тестирование алгоритмов с использованием JUnit.</a></li>
      <li><a href="#q28">28. Модульное тестирование доменной модели с использованием JUnit.</a></li>
      <li><a href="#q29">29. Система Selenium. Архитектура, основные команды написания сценариев.</a></li>
      <li><a href="#q30">30. Система Selenium. Assertion & Verification. Команды. Команды wait**.</a></li>
      <li><a href="#q31">31. Система Selenium. Selenium RC, WebDriver, Grid.</a></li>
      <li><a href="#q32">32. Язык XPath. Основные конструкции, оси. Системные функции.</a></li>
      <li><a href="#q33">33. Язык XPath. Функции с множествами. Строковые, логические и числовые функции.</a></li>
      <li><a href="#q34">34. Apache JMeter. Архитектура, Элементы тестового плана. Последовательность выполнения.</a></li>
      <li><a href="#q35">35. Apache Jmeter. Дополнительные возможности. Распределенное тестирование.</a></li>
      <li><a href="#q36">36. Область деятельности тестирования безопасности. Риски безопасности. Цифровые активы (digital assets). Методы доступа и обеспечения безопасности. Политики безопасности.</a></li>
      <li><a href="#q37">37. Тестирование безопасности. Практически используемые методы. Безопасный код. Основные подходы. Common Weakness Enumeration</a></li>
      <li><a href="#q38">38. Fuzzy testing (Фаззинг). Типы фаззинга</a></li>
      <li><a href="#q39">39. Penertration Testing. Тестирование на проникновение. Dynamic Application Security Testing (DAST) Tools.</a></li>
      <li><a href="#q40">40. Организация тестов безопасности в циклах и типах разработки. Тестирование общих механизмов безопасности.</a></li>
    </ul>
  </header>

  <section id="q1">
    <h2>1. Понятие тестирования ПО. Основные определения.</h2>
    <p>Тестирование программного обеспечения (Software Testing) — проверка соответствия реальных и ожидаемых результатов поведения программы, проводимая на конечном наборе тестов, выбранном определённом образом. [IEEE Guide to Software Engineering Body of Knowledge, SWEBOK, 2004] В более широком смысле, тестирование — это одна из техник контроля качества, включающая в себя активности по планированию работ (Test Management), проектированию тестов (Test Design), выполнению тестирования (Test Execution) и анализу полученных результатов (Test Analysis).</p>
    <p>Верификация (Verification) — это процесс оценки системы или её компонентов с целью определения удовлетворяют ли результаты текущего этапа разработки условиям, сформированным в начале этого этапа [IEEE]. Т.е. выполняются ли наши цели, сроки, задачи по разработке проекта, определенные в начале текущей фазы.</p>
    <p>Валидация (Validation) — это определение соответствия разрабатываемого ПО ожиданиям и потребностям пользователя, требованиям к системе [BS7925-1].</p>
    <p>План Тестирования (Test Plan) — это документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения.</p>
    <p>Тест дизайн (Test Design) — это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования.</p>
    <p>Тестовый случай (Test Case) — это артефакт, описывающий совокупность шагов, конкретных условий и параметров, необходимых для проверки реализации тестируемой функции или её части.</p>
    <p>Баг/Дефект Репорт (Bug Report) — это документ, описывающий ситуацию или последовательность действий приведшую к некорректной работе объекта тестирования, с указанием причин и ожидаемого результата.</p>
    <p>Тестовое Покрытие (Test Coverage) — это одна из метрик оценки качества тестирования, представляющая собой плотность покрытия тестами требований либо исполняемого кода.</p>
    <p>Детализация Тест Кейсов (Test Case Specification) — это уровень детализации описания тестовых шагов и требуемого результата, при котором обеспечивается разумное соотношение времени прохождения к тестовому покрытию.</p>
    <p>Время Прохождения Тест Кейса (Test Case Pass Time) — это время от начала прохождения шагов тест кейса до получения результата теста.</p>
  </section>

  <section id="q2">
    <h2>2. Цели и принципы тестирования (ISTQB).</h2>
    <p>Цель тестирования — проверка соответствия ПО предъявляемым требованиям, обеспечение уверенности в качестве ПО, поиск очевидных ошибок в программном обеспечении, которые должны быть выявлены до того, как их обнаружат пользователи программы.</p>
    <p>Принципы тестирования:</p>
    <ol>
      <li>Тестирование демонстрирует наличие дефектов (Testing shows presence of defects) — Тестирование только снижает вероятность наличия дефектов, которые находятся в программном обеспечении, но не гарантирует их отсутствия.</li>
      <li>Исчерпывающее тестирование невозможно (Exhaustive testing is impossible) — Полное тестирование с использованием всех входных комбинаций данных, результатов и предусловий физически невыполнимо (исключение — тривиальные случаи).</li>
      <li>Раннее тестирование (Early testing) — Следует начинать тестирование на ранних стадиях жизненного цикла разработки ПО, чтобы найти дефекты как можно раньше.</li>
      <li>Скопление дефектов (Defects clustering) — Большая часть дефектов находится в ограниченном количестве модулей.</li>
      <li>Парадокс пестицида (Pesticide paradox) — Если повторять те же тестовые сценарии снова и снова, в какой-то момент этот набор тестов перестанет выявлять новые дефекты.</li>
      <li>Тестирование зависит от контекста (Testing is context depending) — Тестирование проводится по-разному в зависимости от контекста. Например, программное обеспечение, в котором критически важна безопасность, тестируется иначе, чем новостной портал.</li>
      <li>Заблуждение об отсутствии ошибок (Absence-of-errors fallacy) — Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Система должна быть удобна пользователю в использовании и удовлетворять его ожиданиям и потребностям.</li>
    </ol>
  </section>

  <section id="q3">
    <h2>3. Основная цель тестирования. Уровень доверия, корректное поведение, реальное окружение.</h2>
    <p>Увеличение приемлемого уровня пользовательского доверия в том, что программа функционирует корректно во всех необходимых обстоятельствах.</p>
    <ul>
      <li>Корректное поведение: определяется из требований к продукту.</li>
      <li>Уровень доверия: наглядность, уровень остаточного обнаружения дефектов, требования к надёжности, что бы это всё ни значило.</li>
      <li>Необходимые обстоятельства — требования реального окружения: реалистичная среда тестирования (схожие наборы данных и т.п.).</li>
    </ul>
  </section>

  <section id="q4">
    <h2>4. Тестирование и качество. Уровни восприятия тестирования в компании.</h2>
    <ul>
      <li>Уровень 0 — тестирование == отладка
        <ul>
          <li>Не отличает некорректное поведение и ошибки в программе</li>
          <li>Не учитывает требования надежности и безопасности</li>
        </ul>
      </li>
      <li>Уровень 1 — предназначение - показать корректность ПО
        <ul>
          <li>Невозможно доказать</li>
          <li>Что значит “ошибок нет”?</li>
          <li>Нет формальных правил</li>
        </ul>
      </li>
      <li>Уровень 2 — Демонстрация ошибок
        <ul>
          <li>Конфликт разработчиков и тестировщиков</li>
        </ul>
      </li>
      <li>Уровень 3 — Тестирование может показать наличие ошибок
        <ul>
          <li>Используя ПО мы подвержены рискам</li>
          <li>Риск – последствия незначительные</li>
          <li>Риск – последствия катастрофические</li>
          <li>Тестировщики и разработчики совместно снижают риски</li>
        </ul>
      </li>
      <li>Уровень 4 — Тестирование - это возможный способ оценки качества программного обеспечения в терминах найденных дефектов
        <ul>
          <li>Функциональное</li>
          <li>Нефункциональное: надежность, практичность, эффективность, сопровождаемость и переносимость</li>
        </ul>
      </li>
    </ul>
  </section>

  <section id="q5">
    <h2>5. Участники тестирования, их роль, квалификация и обязанности.</h2>
    <ul>
      <li>Проектирование тестов
        <ul>
          <li>На основании формальных критериев</li>
          <li>На основании знаний предметной области, опыта и экспертизы</li>
        </ul>
      </li>
      <li>Автоматизация тестов
        <ul>
          <li>Знание средств, скриптов</li>
        </ul>
      </li>
      <li>Исполнение тестов
        <ul>
          <li>Нет специальных требований к квалификации</li>
        </ul>
      </li>
      <li>Анализ результатов
        <ul><li>Знания предметной области</li></ul>
      </li>
    </ul>
  </section>

  <section id="q6">
    <h2>6. Мониторинг прогресса и контроль тестирования (ISTQB)</h2>
    <p>Целью мониторинга тестирования является предоставление результата и обзора процесса тестирования. Информация отслеживается вручную или автоматически и может быть использована для измерения критериев выхода, таких как покрытие. Метрики также могут быть использованы для оценки прогресса тестирования по сравнению с запланированным расписанием и бюджетом.</p>
    <p>Обычные тестовые метрики включают в себя:</p>
    <ul>
      <li>Процент проделанной работы по подготовке тестовых сценариев (или процентное соотношение запланированных и подготовленных сценариев);</li>
      <li>Процент проделанной работы по подготовке тестового окружения;</li>
      <li>Выполнение тестовых сценариев (например, количество выполненных/невыполненных тестовых сценариев, успешно пройденных/неудачных тестовых сценариев);</li>
      <li>Информация о дефектах (например, плотность дефектов, количество найденных и исправленных дефектов, интенсивность отказов и результаты повторного тестирования);</li>
      <li>Тестовое покрытие требований, рисков или кода;</li>
      <li>Субъективная уверенность тестировщиков в продукте;</li>
      <li>Даты контрольных точек тестирования;</li>
      <li>Стоимость тестирования, включая стоимость по сравнению с выгодой нахождения следующего дефекта или запуска следующего теста.</li>
    </ul>
    <p>Контроль тестирования описывает любые направляющие или корректирующие действия, принятые как результат по полученной и собранной информации и значениям метрик. Контроль тестирования может затрагивать любые действия по тестированию, а так же воздействовать на другие действия и задачи жизненного цикла ПО.</p>
    <p>Примеры действий по контролю тестирования:</p>
    <ul>
      <li>Принятие решений на основании данных мониторинга тестирования;</li>
      <li>Повторная расстановка приоритетов при возникновении установленного риска (например, задержка выпуска ПО);</li>
      <li>Изменение графика тестирования согласно доступности тестового окружения;</li>
    </ul>
  </section>

  <section id="q7">
    <h2>7. Модульное тестирование. Понятие модуля. Драйверы и заглушки.</h2>
  </section>
  <section id="q8">
    <h2> 8. V-образная модель. Статическое и динамическое тестирование.</h2>
  </section>
  <section id="q9">
    <h2> 9. Валидация и верификация. Тестирование методом "чёрного" и "белого" ящика.</h2>
  </section>
  <section id="q10">
    <h2> 10. Тестовый случай, тестовый сценарий и тестовое покрытие.</h2>
  </section>
  <section id="q11">
    <h2> 11. Полное тестовое покрытие. Оценка объема и времени полного покрытия.</h2>
  </section>
  <section id="q12">
    <h2> 12. Повторяемость тестового сценария. Автоматизированное тестирование. Регрессионное тестирование.</h2>
  </section>
  <section id="q13">
    <h2> 13. Цели и задачи интеграционного тестирования. Алгоритм интеграционного тестирования. Стратегии интеграции.</h2>
  </section>
  <section id="q14">
    <h2>14. Тестирование системы целиком - системное тестирование.</h2>
  </section>
  <section id="q15">
    <h2>15. Тестирование возможностей, стабильности, отказоустойчивости, совместимости. Тестирование производительности - CARAT.</h2>
  </section>
  <section id="q16">
    <h2>16. Альфа и Бета тестирование. Приемочное тестирование.</h2>
  </section>
  <section id="q17">
    <h2>17. Статическое тестирование. Рецензия, технические анализ, сквозной контроль.</h2>
  </section>
  <section id="q18">
    <h2>18. Статическое тестирование. Инспекции.</h2>
  </section>
  <section id="q19">
    <h2>19. Статическое тестирование. Статический анализ кода.</h2>
  </section>
  <section id="q20">
    <h2>20. Выбор тестового покрытия с помощью анализа эквивалентности. Анализ граничных значений.</h2>
  </section>
  <section id="q21">
    <h2>21. Выбор тестового покрытия с помощью таблицы решений.</h2>
  </section>
  <section id="q22">
    <h2>22. Выбор тестового покрытия с помощью диаграммы состояний и таблицы переходов.</h2>
  </section>
  <section id="q23">
    <h2>23. Выбор тестового покрытия с помощью функционального тестирования.</h2>
  </section>
  <section id="q24">
    <h2>24. Библиотека JUnit. Класс junit.framework.Assert. Основные аннотации для исполнения тестов.</h2>
  </section>
  <section id="q25">
    <h2>25. Библиотека JUnit. Дополнительные возможности, запуск с параметрами.</h2>
  </section>
  <section id="q26">
    <h2>26. Анализ эквивалентности с использованием JUnit.</h2>
  </section>
  <section id="q27">
    <h2>27. Тестирование алгоритмов с использованием JUnit.</h2>
  </section>
  <section id="q28">
    <h2>28. Модульное тестирование доменной модели с использованием JUnit.</h2>
  </section>
  <section id="q29">
    <h2>29. Система Selenium. Архитектура, основные команды написания сценариев.</h2>
  </section>
  <section id="q30">
    <h2>30. Система Selenium. Assertion & Verification. Команды. Команды wait**.</h2>
  </section>
  <section id="q31">
    <h2>31. Система Selenium. Selenium RC, WebDriver, Grid.</h2>
  </section>
  <section id="q32">
    <h2>32. Язык XPath. Основные конструкции, оси. Системные функции.</h2>
  </section>
  <section id="q33">
    <h2>33. Язык XPath. Функции с множествами. Строковые, логические и числовые функции.</h2>
  </section>
  <section id="q34">
    <h2>34. Apache JMeter. Архитектура, Элементы тестового плана. Последовательность выполнения.</h2>
  </section>
  <section id="q35">
    <h2>35. Apache Jmeter. Дополнительные возможности. Распределенное тестирование.</h2>
  </section>
  <section id="q36">
    <h2>36. Область деятельности тестирования безопасности. Риски безопасности. Цифровые активы (digital assets). Методы доступа и обеспечения безопасности. Политики безопасности</h2>
  </section>
  <section id="q37">
    <h2>37. Тестирование безопасности. Практически используемые методы. Безопасный код. Основные подходы. Common Weakness Enumeration</h2>
  </section>
  <section id="q38">
    <h2>38. Fuzzy testing (Фаззинг). Типы фаззинга</h2>
  </section>
  <section id="q39">
    <h2>39. Penertration Testing. Тестирование на проникновение. Dynamic Application Security Testing (DAST) Tools</h2>
  </section>
  <section id="q40">
    <h2>40. Организация тестов безопасности в циклах и типах разработки. Тестирование общих механизмов безопасности.</h2>
  </section>
  <footer>
    <b>ВНИМАНИЕ!</b> При ответах на вопросы 21-40 обязательно использование примера (ов).
  </footer>
</div>
</body>
